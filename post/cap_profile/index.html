<!doctype html><html dir=ltr lang=cn data-theme=dark><head><title>KaitoShy | CAP 的基础了解</title><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="这篇文章讲述的是 CAP 的基础理论。"><link rel=stylesheet href=/css/main.min.f79a5de55310cc058fc81804d033ddb955937d778bd533d9ea05b1c798501013.css integrity="sha256-95pd5VMQzAWPyBgE0DPduVWTfXeL1TPZ6gWxx5hQEBM=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=/post/cap_profile/><script type=text/javascript src=/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin=anonymous></script><script type=text/javascript src=/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="CAP 的基础了解"><meta name=twitter:description content="这篇文章讲述的是 CAP 的基础理论。"></head><body><div class="sidebar animated fadeInDown"><div class=logo-title><div class=title><img src=/images/avatar.png alt="profile picture"><h3 title><a href=/>I'm KaitoShy</a></h3><div class=description><p>Java And PHP Developer</p></div></div></div><ul class=social-links><li><a href=https://github.com/plutokaito rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:kaito78@163.com rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul><div class=footer><div class=by_farbox>&copy; KaitoShy 2021 - 2021</div></div></div><div class=main><div class="page-top animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><ul class=nav id=navMenu><li><a href=/ title>主页(Home)</a></li><li><a href=/post/ title>博客(Blog)</a></li><li><a href=/about/ title>关于(About)</a></li><li><a href=/tags/ title>标签(tags)</a></li><li><a href=/contact/ title>联系(Contact)</a></li><li class=theme-switch-item><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post animated fadeInDown"><div class=post-content><div class=post-title><h3>CAP 的基础了解</h3><div class=info><em class="fas fa-calendar-day"></em><span class=date>Wed, Jun 30, 2021</span>
<em class="fas fa-stopwatch"></em><span class=reading-time></span></div></div><h2 id=前言>前言</h2><p>该篇文章主要是讲述了分布式系统中 CAP 的基本理解，主要来源是极客时间专栏 <a href=https://time.geekbang.org/column/intro/100006601>从0开始学架构</a>, 有兴趣的可以了解一下。以下的英文原文来自于 <a href=https://robertgreiner.com/cap-theorem-revisited/>CAP Theorem: Revisited</a></p><h1 id=什么是-cap-理论>什么是 CAP 理论</h1><p>CAP 定理又被称为布鲁尔定理。只有在互联和共享数据的分布式系统中讨论 CAP 才会有意义，由此可以看出 CAP 讨论的是对数据的读写操作，而非是费不是系统的全部。</p><p>C: Consistency(一致性):</p><blockquote><p>A read is guaranteed to return the most recent write for a given client.</p></blockquote><p>对于某个指定的客户端，读操作能保证返回最新的写操作的结果。因为在事务在执行过程中， client 是无法读取到未提交的数据的，有点类似于数据库的 rr 机制， 只有等到事务提交后， client 才能读取到事务写入的数据，而如果事务失败则进行回滚， client 也不会读取到事务中间写入的数据。核心是：保证客户端获取的数据都是最新的。</p><p>A: Availability(可用性):</p><blockquote><p>A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).</p></blockquote><p>非故障节点在合理的时间内返回一个合理的结果（非错误和超时）。 重点是 返回的结果是非错误和超时。</p><p>P: Partition Tolerance (分区容忍性):</p><blockquote><p>The system will continue to function when network partitions occur.</p></blockquote><p>当出现网络分区后，系统能够继续“履行职责”。 网络分区导致的原因： 不论什么原因，可能是丢包，可能是链接中断，还有可能是拥塞， 只要是导致了一部分节点和另外一部分无法通信。就通通算在里面。但出现网络故障时：系统还能运行。</p><h2 id=cap-应用>CAP 应用</h2><p>在分布式系统中， 我们无法保证网络 100% 可靠，可能出故障，分区是一个必然的现象，因此必须选择 P 要素。</p><ul><li>CP ： 一致性和分区容忍性</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2734050/1624242751996-188c39d7-08f4-4ba1-8614-3d031dd52c4d.png#height=180&id=Yt8WK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=523&originalType=binary&ratio=1&size=21773&status=done&style=none&width=259" alt=image.png>
A1 当更新 x 的值为 3 时， A2 此时还是 x = 2, 当 client 去读该系统的 x 值， 按照一致性原则，此时应该返回 Error， 这样就不满足了可用性了。</p><ul><li>AP:  可用性和分区容忍性</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2734050/1624242954429-20bb87e1-acc8-492a-a0ce-1fffd18193f6.png#height=174&id=dNvCz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=398&originWidth=529&originalType=binary&ratio=1&size=21802&status=done&style=none&width=231" alt=image.png>
A1 更新 x = 3时， A2 还是 x = 2， 当 client 去读该系统的 x 的值时, 按照 A 可用性来说，此时返回不是应该 error 或者超时，而是一个合理的值 2。
​</p><p>很多工程上都选择了 AP 并保证了最终一致性，此时用的方式为：人工数据订正和补偿，定时脚本批量检查和修复。</p></div><div class=post-footer><div class=info><span class=separator><a class=tag href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></span></div></div></div></div></div></div><script type=text/javascript src=/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js integrity="sha256-g8sd1f6o1C2H0eYBoH+qcwia0O+cz+Xa9gQSievMTkY=" crossorigin=anonymous></script><script async defer src=https://scripts.simpleanalyticscdn.com/latest.js></script><noscript><img src=https://queue.simpleanalyticscdn.com/noscript.gif alt></noscript></body></html>
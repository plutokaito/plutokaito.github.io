<!doctype html><html dir=ltr lang=cn data-theme><head><title>临海筱轩 | 缓存 (番外)- 利用 HashMap 和链表实现 LRU_CACHE</title><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="该篇文章主要是讲述了怎么利用 HashMap 和链表实现 LRU_CACHE"><meta name=google-site-verification content="L6xe0i6HBiJAWiH5QHEw9sqEVLcBuUl5vn_4ZkCprXw"><link rel=stylesheet href=/css/main.min.69a557b4fc895e1566037155c2b37c752bb8ccf82803bf8551c60ae44f0f4e23.css integrity="sha256-aaVXtPyJXhVmA3FVwrN8dSu4zPgoA7+FUcYK5E8PTiM=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=/post/simple_lru_cache/><script type=text/javascript src=/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin=anonymous></script><script type=text/javascript src=/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="缓存 (番外)- 利用 HashMap 和链表实现 LRU_CACHE"><meta name=twitter:description content="该篇文章主要是讲述了怎么利用 HashMap 和链表实现 LRU_CACHE"></head><body><div class="sidebar animated fadeInDown"><div class=logo-title><div class=title><img src=/images/avatar.png alt="profile picture"><h3 title><a href=/>I'm KaitoShy</a></h3><div class=description><p>Java And PHP Developer</p></div></div></div><ul class=social-links><li><a href=https://github.com/plutokaito rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:kaito78@163.com rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul><div class=footer><div class=by_farbox>&copy; 临海筱轩 2021 - 2021</div></div></div><div class=main><div class="page-top animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><ul class=nav id=navMenu><li><a href=/ title>主页(Home)</a></li><li><a href=/post/ title>博客(Blog)</a></li><li><a href=/about/ title>关于(About)</a></li><li><a href=/tags/ title>标签(tags)</a></li><li><a href=/contact/ title>联系(Contact)</a></li><li class=theme-switch-item><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post animated fadeInDown"><div class=post-content><div class=post-title><h3>缓存 (番外)- 利用 HashMap 和链表实现 LRU_CACHE</h3><div class=info><em class="fas fa-calendar-day"></em><span class=date>Tue, Aug 24, 2021</span>
<em class="fas fa-stopwatch"></em><span class=reading-time></span></div></div><p>学习缓存淘汰策略时, 有种策略为 LRU。 在学习这个算法中，做了一些笔记。 这个不是官方实现，是从 leetCode 中选了一种比较经典的算法来帮助我看懂原理和自己实现方式。</p><h2 id=实现一-使用-java-linkedhashmap-实现>实现一： 使用 Java LinkedHashMap 实现</h2><p>代码如下：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>LRUCacheDemo</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>map</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CAPACITY</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>LRUCacheDemo</span><span class=o>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>CAPACITY</span> <span class=o>=</span> <span class=n>capacity</span><span class=o>;</span>

        <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;(</span><span class=n>capacity</span><span class=o>,</span> <span class=n>0</span><span class=o>.</span><span class=na>75f</span><span class=o>,</span> <span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
            <span class=nd>@Override</span>
            <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>removeEldestEntry</span><span class=o>(</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>eldest</span><span class=o>)</span> <span class=o>{</span>
                <span class=k>return</span> <span class=n>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=n>CAPACITY</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>};</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>get</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>map</span><span class=o>.</span><span class=na>getOrDefault</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=o>-</span><span class=n>1</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>这里使用了 LinkedHashMap 中的 removeEldestEntry 方法，该方法会删除年纪最老的节点，这个年纪最老的节点对比着 JVM 中的 Old 区一起来理解，即经常使用的会被删除，新增就会产生新的对象，而不会被使用的就会一直增长，就会为成为年龄最长的节点。</p><p>这是一种投机的做法。如果是面试，这可能不是面试官所需要的答案。那么我们换一种实现。</p><h2 id=链表--hashmap-实现>链表 + HashMap 实现</h2><p>通过上述的代码，我们了解到了，当 cache 中的数据到达容量数时， 会删除年龄最大的节点，不断使用的节点会一直不断产生新的节点。那么我们就用一个链表来表示这个过程， 初始链表中设有头结点和尾结点。用有容量大小的 HashMap 作为容量的限定和链表中节点的记录。节点中有 key，value，上一个节点，下一个节点。 链表和 HashMap 整个组成了一个 cache, 整体如下图所示。</p><p><img src=/images/post/lru/864E454A-7135-418a-AB12-12371D5FFD20.png alt=get_cache></p><p>获取的数据的时候，从 map 中获取相应的节点，然后删除原有的节点，新建一个节点放入链表中。</p><p>节点删除数据流程如下图所示。</p><p><img src=/images/post/lru/Image_1.png alt=del_node></p><p>删除的大体流程是：现将要删除的节点的 next 节点放入删除节点的 prev 节点的 next 中，将删除节点的 prev 中的值给到删除节点 next 节点中的 prev 中。</p><p>节点新增数据流程下图所示：</p><p><img src=/images/post/lru/BD947AEF-8225-43d9-8B89-53CE5F8087F3.png alt=add_node></p><p>新增的大体流程是：在 head 后面新增一个节点，将 head next 节点放入到 node 的 next 中，将 head 放入 node 的 prev 中， 将 node 节点放入 head next 节点中的 prev 中， 将节点放入 head 节点的 next 中。</p><p>这里变完成了节点的新增和删除操作。接下就要往 cache 中 set 数据了。大体流程图如下：</p><p><img src=/images/post/lru/Image_3.png alt=set_cache></p><p>代码如下：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Node</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>key</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>Node</span> <span class=n>prev</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>Node</span> <span class=n>next</span><span class=o>;</span>

    <span class=n>Node</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>key</span> <span class=o>=</span> <span class=n>key</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>val</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>大体流程是：</p><ol><li>先判断 map 中是否当前 key， 如果 key 存在就获取当前 node， 并删除链表中相应的 node，修改 node 中 value 的值，并将新的 node 插入到链表中 。</li><li>如果不存在当前 key，继续判断是否达到 map 中的容量了，如果 map 中容量满了，则删除 map 中 tail 节点的 prev 节点中 key-node 值，删除链表中 tail.prev 节点， 写入 map 新的 key-node 值， 链表新增新的 node。 如果没有 map 的容量没有满， 则获取 map node 的值，删除链表中原有节点，新增节点， 将新的 key-node 的值写入到 map 中，数量累加。 整体代码如下:</li></ol><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>LRUCache</span> <span class=o>{</span>
    <span class=kd>class</span> <span class=nc>Node</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>;</span>
        <span class=n>Node</span> <span class=n>prev</span><span class=o>,</span> <span class=n>next</span><span class=o>;</span>

        <span class=kd>public</span> <span class=nf>Node</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>this</span><span class=o>.</span><span class=na>key</span> <span class=o>=</span> <span class=n>key</span><span class=o>;</span>
            <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=o>}</span>

    <span class=o>}</span>


    <span class=kd>private</span> <span class=kt>int</span> <span class=n>size</span><span class=o>,</span> <span class=n>capacity</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>Node</span> <span class=n>head</span><span class=o>,</span> <span class=n>tail</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Node</span><span class=o>&gt;</span> <span class=n>cache</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>LRUCache</span><span class=o>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>head</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>0</span><span class=o>);</span>
        <span class=n>tail</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>0</span><span class=o>);</span>
        <span class=k>this</span><span class=o>.</span><span class=na>head</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>tail</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>head</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>tail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

        <span class=k>this</span><span class=o>.</span><span class=na>capacity</span> <span class=o>=</span> <span class=n>capacity</span><span class=o>;</span>
        <span class=n>size</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>mapCapacity</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)(</span><span class=n>capacity</span> <span class=o>/</span><span class=n>0</span><span class=o>.</span><span class=na>75f</span> <span class=o>+</span> <span class=n>1</span><span class=o>);</span>
        <span class=n>cache</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;(</span><span class=n>mapCapacity</span><span class=o>);</span>
    <span class=o>}</span>


    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>node</span><span class=o>.</span><span class=na>prev</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=n>Node</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>node</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
        <span class=n>node</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>

        <span class=n>head</span><span class=o>.</span><span class=na>next</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
        <span class=n>head</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
    <span class=o>}</span>


    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>get</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
       <span class=k>if</span> <span class=o>(</span><span class=n>cache</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>key</span><span class=o>))</span> <span class=o>{</span>
          <span class=n>Node</span> <span class=n>node</span> <span class=o>=</span> <span class=n>cache</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
          <span class=n>remove</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
          <span class=n>add</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
          <span class=k>return</span> <span class=n>node</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
       <span class=o>}</span>

        <span class=k>return</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>put</span><span class=o>(</span><span class=kt>int</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>Node</span> <span class=n>node</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cache</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>key</span><span class=o>))</span> <span class=o>{</span>
            <span class=n>node</span> <span class=o>=</span> <span class=n>cache</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
            <span class=n>remove</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
            <span class=n>node</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>

            <span class=k>if</span> <span class=o>(</span><span class=n>capacity</span> <span class=o>&gt;</span> <span class=n>size</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>size</span><span class=o>++;</span>
            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
                <span class=n>cache</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=n>tail</span><span class=o>.</span><span class=na>prev</span><span class=o>.</span><span class=na>key</span><span class=o>);</span>
                <span class=n>remove</span><span class=o>(</span><span class=n>tail</span><span class=o>.</span><span class=na>prev</span><span class=o>);</span>
            <span class=o>}</span>

            <span class=n>cache</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>node</span><span class=o>);</span>
        <span class=o>}</span>

        <span class=n>add</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div></div><div class=post-footer><div class=info><span class=separator><a class=tag href=/tags/%E7%BC%93%E5%AD%98/>缓存</a><a class=tag href=/tags/%E7%AE%97%E6%B3%95/>算法</a></span></div></div></div></div></div></div><script type=text/javascript src=/js/medium-zoom.min.83cb1dd5fea8d42d87d1e601a07faa73089ad0ef9ccfe5daf6041289ebcc4e46.js integrity="sha256-g8sd1f6o1C2H0eYBoH+qcwia0O+cz+Xa9gQSievMTkY=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z2224MZXW3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Z2224MZXW3')</script><script async defer src=https://scripts.simpleanalyticscdn.com/latest.js></script><noscript><img src=https://queue.simpleanalyticscdn.com/noscript.gif alt></noscript></body></html>